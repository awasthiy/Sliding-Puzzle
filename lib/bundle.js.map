{"version":3,"sources":["webpack/bootstrap 8a7c3d78bb6de7702a34","./lib/main.js","./lib/view.js","./lib/game.js","./lib/board.js","./lib/move_error.js","./lib/solver.js","./lib/puzzle_node.js","./lib/priority_queue.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;ACND;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB,6BAA6B;AACnD;AACA;;AAEA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AC7GA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AClBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9HA;AACA;AACA;;AAEA;;;;;;;ACJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACjBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,gCAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8a7c3d78bb6de7702a34\n **/","var View = require('./view');\nvar Board = require('./board');\n\n$(function () {\n  var canvasEl = $('.game-window');\n  new View(canvasEl);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var Game = require('./game');\n\nvar View = function () {\n  this.$gridPuzzle = $('#grid-puzzle');\n  this.$gridSolution = $('#grid-solution');\n  this.$time = $(\".time\");\n  this.$moves = $(\".moves\");\n  this.setupWindow();\n};\n\nView.prototype.setupWindow = function () {\n  $('#level').on('input change', function (event) {\n    var gridSize = event.currentTarget.value;\n    $('#rangeText').text('Grid Size: ' + gridSize + ' x ' + gridSize);\n   });\n\n  $(\"#new-game\").click(function (event) {\n    event.preventDefault();\n    this.newGame(parseInt($('#level').val()));\n  }.bind(this));\n};\n\nView.prototype.newGame = function (gridSize) {\n  this.$gridPuzzle.removeClass('game-over');\n  this.$gridPuzzle.html('');\n  this.$gridSolution.html('');\n  clearInterval(this.timeDisplay);\n  this.$gridPuzzle.off(\"click\");\n  this.game = new Game(gridSize);\n  this.bindEvents();\n  this.time = new Date();\n  this.setupBoard();\n  this.timer();\n};\n\nView.prototype.bindEvents = function () {\n  this.$gridPuzzle.on('click', 'li', (function (event) {\n    var $square = $(event.currentTarget);\n    this.makeMove($square);\n  }).bind(this));\n};\n\nView.prototype.makeMove = function ($square) {\n  var pos = $square.data(\"pos\");\n  var value = $square.attr(\"value\");\n  var $oldEmpty = $(\".empty\");\n\n  try {\n    this.game.playMove(pos);\n  } catch (e) {\n    // alert(\"Invalid move! Try again.\");\n    return;\n  }\n  this.$moves.html(parseInt(this.$moves.html()) + 1);\n\n  $square.removeAttr(\"value\");\n  $square.addClass('empty');\n  $oldEmpty.attr(\"value\", value);\n  $oldEmpty.removeClass('empty');\n\n  if (this.game.isOver()) {\n    this.$gridPuzzle.addClass('game-over');\n    clearInterval(this.timeDisplay);\n    this.$gridPuzzle.off(\"click\");\n  }\n};\n\nView.prototype.setupBoard = function () {\n  for (var rowIdx = 0; rowIdx < this.game.gridSize; rowIdx++) {\n    var $ul = $('<ul>');\n    var $sul = $('<ul>');\n\n    for (var colIdx = 0; colIdx < this.game.gridSize; colIdx++) {\n      var num = this.game.board.grid[rowIdx * this.game.gridSize + colIdx];\n      var snum = this.game.board.solution[rowIdx * this.game.gridSize + colIdx];\n      var $li;\n      if (num === null) {\n        $li = $('<li></li>');\n        $li.addClass('empty');\n      } else {\n        $li = $('<li value=' + num + '></li>');\n      }\n      $li.data('pos', rowIdx * this.game.gridSize + colIdx);\n\n      var $sli;\n      if (snum === null) {\n        $sli = $('<li></li>');\n      } else {\n        $sli = $('<li value=' + snum + '></li>');\n      }\n\n      $ul.append($li);\n      $sul.append($sli);\n    }\n\n    this.$gridPuzzle.append($ul);\n    this.$gridSolution.append($sul);\n  }\n\n  this.$time.html(0);\n  this.$moves.html(0);\n};\n\nView.prototype.timer = function () {\n  this.timeDisplay = setInterval(function () {\n    this.$time.html(Math.floor((new Date() - this.time) / 1000));\n  }.bind(this), 1000);\n};\n\nmodule.exports = View;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/view.js\n ** module id = 1\n ** module chunks = 0\n **/","var Board = require('./board');\nvar Solver = require('./solver');\n\nfunction Game (gridSize) {\n  this.gridSize = gridSize || 3;\n  this.board = new Board(this.gridSize);\n  this.initialBoard = this.board.duplicate();\n  window.game = this;\n}\n\nGame.prototype.playMove = function (pos) {\n  this.board.move(pos);\n};\n\nGame.prototype.isOver = function () {\n  return this.board.isOver();\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 2\n ** module chunks = 0\n **/","var MoveError = require(\"./move_error\");\n\nfunction Board (gridSize) {\n  if (gridSize) {\n    this.gridSize = gridSize;\n    this.solution = Board.tileContent(this.gridSize);\n    while (!this.grid || this.isOver()) {\n      this.grid = Board.makeSolvable(this.solution);\n    }\n    this.emptyPosition = this.grid.indexOf(null);\n  }\n}\n\nBoard.prototype.duplicate = function () {\n  var newBoard = new Board();\n  newBoard.gridSize = this.gridSize;\n  newBoard.solution = this.solution;\n  newBoard.grid = this.grid.slice(0);\n  newBoard.emptyPosition = this.emptyPosition;\n  return newBoard;\n};\n\nfunction shuffleArray(array) {\n  var shuffled = array.slice(0);\n  for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n  }\n  return shuffled;\n}\n\nBoard.makeSolvable = function (array) {\n  var tileArray = shuffleArray(array);\n  if (Board.isSolvable(tileArray)) {\n    return tileArray;\n  } else {\n    return Board.makeSolvable(tileArray);\n  }\n};\n\nBoard.tileContent = function (gridSize) {\n  var tileRange = [];\n  for (var i = 1; i < Math.pow(gridSize, 2); i++) {\n    tileRange.push(i);\n  }\n  tileRange.push(null);\n  return tileRange;\n};\n\nBoard.isSolvable = function (tileArray) {\n  var parity = 0;\n  var row = 0;\n  var gridSize = Math.sqrt(tileArray.length);\n  var blankRow = 0;\n\n  for (var i = 0; i < tileArray.length; i++) {\n    if (i % gridSize === 0) {\n      row++;\n    }\n\n    if (tileArray[i] === null) {\n      blankRow = row;\n    }\n\n    for (var j = i + 1; j < tileArray.length; j++) {\n      if (tileArray[i] > tileArray[j] && tileArray[j] !== null) {\n        parity++;\n      }\n    }\n  }\n\n  if (gridSize % 2 === 0 && blankRow % 2 !== 0) {\n    return parity % 2 !== 0;\n  } else {\n    return parity % 2 === 0;\n  }\n};\n\nBoard.prototype.isOver = function () {\n  return this.solution.toString() === this.grid.toString();\n};\n\nBoard.prototype.surroundingPositions = function (origPos) {\n  var positions = [];\n  var origCoords = this.coords(origPos);\n  positions.push(origPos + 1);\n  positions.push(origPos - 1);\n  positions.push(origPos + this.gridSize);\n  positions.push(origPos - this.gridSize);\n  return  positions.filter(function (pos) {\n    var posCoords = this.coords(pos);\n    var vertDist = Math.abs(posCoords[1] - origCoords[1]);\n    var horizDist = Math.abs(posCoords[0] - origCoords[0]);\n    return this.isValidPos(pos) && horizDist + vertDist == 1;\n  }.bind(this));\n};\n\nBoard.prototype.coords = function(pos) {\n  var row = Math.floor(pos / this.gridSize);\n  var col = pos % this.gridSize;\n  return [row, col];\n};\n\nBoard.prototype.isValidPos = function (pos) {\n  return 0 <= pos && pos < Math.pow(this.gridSize, 2);\n};\n\nBoard.prototype.validMoves = function () {\n  return this.surroundingPositions(this.emptyPosition);\n};\n\nBoard.prototype.isValidMove = function (pos) {\n  return this.validMoves().includes(pos);\n};\n\nBoard.prototype.move = function (pos) {\n  if (!this.isValidMove(pos)) {\n    throw new MoveError(\"Is not valid position\");\n  }\n  this.grid[this.emptyPosition] = this.grid[pos];\n  this.emptyPosition = pos;\n  this.grid[pos] = null;\n};\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/board.js\n ** module id = 3\n ** module chunks = 0\n **/","function MoveError (msg) {\n  this.msg = msg;\n}\n\nmodule.exports = MoveError;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/move_error.js\n ** module id = 4\n ** module chunks = 0\n **/","var Board = require(\"./board\");\nvar PuzzleNode = require(\"./puzzle_node\");\nvar PriorityQueue = require(\"./priority_queue\");\n\nfunction Solver(board) {\n  var solverBoard = board.duplicate();\n  this.visited = {};\n  this.visited[solverBoard.grid] = true;\n  this.solution = this.findSolution(solverBoard);\n}\n\nSolver.prototype.possibleBoards = function (board) {\n  var boards = [];\n  board.validMoves().forEach(function(pos) {\n    var newBoard = board.duplicate();\n    newBoard.move(pos);\n    if (!this.visited[newBoard.grid]) {\n      boards.push(newBoard);\n      this.visited[newBoard.grid] = true;\n    }\n  }.bind(this));\n  return boards;\n};\n\nSolver.manhattanDistace = function (board) {\n  return board.grid.reduce(function(distance, currentTile, index) {\n    var adder = 0;\n    if (currentTile) {\n      var correctPos = currentTile - 1;\n      var colDist = Math.abs(index % board.gridSize - correctPos % board.gridSize);\n      var rowDist = Math.abs(Math.floor(index / board.gridSize) - Math.floor(correctPos / board.gridSize));\n      adder = colDist + rowDist;\n    }\n    return distance + adder;\n  }, 0);\n};\n\nSolver.prototype.findSolution = function (board) {\n  var rootNode = new PuzzleNode(board);\n  rootNode.priority = Solver.manhattanDistace(rootNode.board);\n  var boardQueue = new PriorityQueue([rootNode]);\n  var currentNode = boardQueue.pop();\n  var solved;\n  while (currentNode) {\n    var currentBoard = currentNode.board;\n    if (currentBoard.isOver()) {\n      solved = currentNode;\n      break;\n    }\n    var nextBoards = this.possibleBoards(currentBoard);\n    boardQueue.add(nextBoards.map(function (board) {\n      var nextNode = new PuzzleNode(board);\n      nextNode.distance = currentNode.distance + 1;\n      nextNode.priority = nextNode.distance + Solver.manhattanDistace(nextNode.board);\n      nextNode.setParent(currentNode);\n      return nextNode;\n    }));\n    currentNode = boardQueue.pop();\n  }\n  return solved;\n};\n\nwindow.Solver = Solver;\nmodule.exports = Solver;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/solver.js\n ** module id = 5\n ** module chunks = 0\n **/","function PuzzleNode(board) {\n  this.board = board;\n  this.parent = null;\n  this.children = [];\n  this.distance = 0;\n  this.priority = 0;\n}\n\nPuzzleNode.prototype.setParent = function (parent) {\n  this.parent = parent;\n  if (this.parent) this.parent.children.push(this);\n};\n\nPuzzleNode.prototype.addChild = function (child) {\n  child.setParent(this);\n};\n\nmodule.exports = PuzzleNode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/puzzle_node.js\n ** module id = 6\n ** module chunks = 0\n **/","function PriorityQueue(nodes) {\n  this.heap = [null];\n  this.add(nodes);\n}\n\nPriorityQueue.prototype = {\n  add: function(nodes) {\n    nodes.forEach(function(node) {\n      this.push(node);\n    }.bind(this));\n  },\n\n  push: function(node) {\n    this.bubble(this.heap.push(node) - 1);\n  },\n\n  // removes and returns the node of highest priority\n  pop: function() {\n    var topVal = this.heap[1];\n    this.heap[1] = this.heap.pop();\n    this.sink(1);\n    return topVal;\n  },\n\n  // bubbles node i up the binary tree based on\n  // priority until heap conditions are restored\n  bubble: function(i) {\n    while (i > 1) {\n      var parentIndex = i >> 1; // <=> floor(i/2)\n\n      // if equal, no bubble (maintains insertion order)\n      if (!this.isHigherPriority(i, parentIndex)) break;\n\n      this.swap(i, parentIndex);\n      i = parentIndex;\n    }\n  },\n\n  // does the opposite of the bubble() function\n  sink: function(i) {\n    while (i * 2 < this.heap.length) {\n      // if equal, left bubbles (maintains insertion order)\n      var leftHigher = true;\n      if (this.heap.length - 1 >= i * 2 + 1) {\n        leftHigher = this.isHigherPriority(i * 2, i * 2 + 1);\n      }\n      var childIndex = leftHigher ? i * 2 : i * 2 + 1;\n\n      // if equal, sink happens (maintains insertion order)\n      if (this.isHigherPriority(i, childIndex)) break;\n\n      this.swap(i, childIndex);\n      i = childIndex;\n    }\n  },\n\n  // swaps the addresses of 2 nodes\n  swap: function(i, j) {\n    var temp = this.heap[i];\n    this.heap[i] = this.heap[j];\n    this.heap[j] = temp;\n  },\n\n  // returns true if node i is higher priority than j\n  isHigherPriority: function(i, j) {\n    return this.heap[i].priority < this.heap[j].priority;\n  }\n};\n\nmodule.exports = PriorityQueue;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/priority_queue.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}