{"version":3,"sources":["webpack/bootstrap 9b38081a2087f7ae46c9","./lib/main.js","./lib/view.js","./lib/game.js","./lib/board.js","./lib/move_error.js","./lib/solver.js","./lib/puzzle_node.js","./lib/priority_queue.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;ACND;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,6BAA6B;AACnD;;AAEA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC,0BAA0B,GAAG,SAAS;AACtE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA,kBAAiB,uBAAuB;AACxC;;AAEA;;;;;;;AC7QA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,eAAe,GAAG,mBAAmB,QAAQ,cAAc,MAAM,YAAY;AAC3F,IAAG;AACH;AACA;AACA;;AAEA;;;;;;;AClKA;AACA;AACA;;AAEA;;;;;;;ACJA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;ACnFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,gCAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9b38081a2087f7ae46c9\n **/","var View = require('./view');\nvar Board = require('./board');\n\n$(function () {\n  var canvasEl = $('.game-window');\n  new View(canvasEl);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var Game = require('./game');\nvar _solutionNodes;\nvar _playing;\n\nvar View = function () {\n  this.$gridPuzzle = $('#grid-puzzle');\n  this.$gridSolution = $('#grid-solution');\n  this.$time = $(\".time\");\n  this.$moves = $(\".moves\");\n  this.$modal = $(\"#solution-modal\");\n  this.$puzzleSolution = $(\"#puzzle-solution\");\n  this.setupWindow();\n};\n\nView.prototype.setupWindow = function () {\n  $('#level').on('input change', function (event) {\n    var gridSize = event.currentTarget.value;\n    $('#rangeText').text('Grid Size: ' + gridSize + ' x ' + gridSize);\n   });\n\n  $(\"#new-game\").click(function (event) {\n    event.preventDefault();\n    this.newGame(parseInt($('#level').val()));\n  }.bind(this));\n\n  $(\"#solver\").click(function (event) {\n    this.$modal.css('display', 'flex');\n    this.solvePuzzle();\n  }.bind(this));\n\n  $(\"#solution-modal-close\").click(function (event) {\n    this.handleCloseModal();\n  }.bind(this));\n\n  $(window).click(function(event) {\n    if (this.$modal.is(event.target)) {\n      this.handleCloseModal();\n    } else if ($.contains(this.$modal[0], event.target) && this.$solverSteps) {\n      this.$solverSteps.focus();\n    }\n  }.bind(this));\n};\n\nView.prototype.handleCloseModal = function () {\n  this.$modal.hide();\n  if (this.$gridSolver) this.handleStopPlay();\n};\n\nView.prototype.newGame = function (gridSize) {\n  this.$gridPuzzle.removeClass('game-over');\n  this.$gridPuzzle.html('');\n  this.$gridSolution.html('');\n  clearInterval(this.timeDisplay);\n  this.$gridPuzzle.off(\"click\");\n  this.game = new Game(gridSize);\n  this.bindEvents();\n  this.time = new Date();\n  this.setupBoard(this.$gridPuzzle, this.game.board.grid);\n  this.setupBoard(this.$gridSolution, this.game.board.solution);\n  this.$time.html(0);\n  this.$moves.html(0);\n  this.timer();\n};\n\nView.prototype.bindEvents = function () {\n  this.$gridPuzzle.on('click', 'li', (function (event) {\n    var $tile = $(event.currentTarget);\n    this.gameMove($tile);\n  }).bind(this));\n};\n\nView.prototype.gameMove = function ($tile) {\n  var pos = $tile.data(\"pos\");\n\n  try {\n    this.game.playMove(pos);\n  } catch (e) {\n    // alert(\"Invalid move! Try again.\");\n    return;\n  }\n\n  View.domMove($tile, this.$gridPuzzle);\n  this.$moves.html(parseInt(this.$moves.html()) + 1);\n\n  if (this.game.isOver()) {\n    this.$gridPuzzle.addClass('game-over');\n    clearInterval(this.timeDisplay);\n    this.$gridPuzzle.off(\"click\");\n  }\n};\n\nView.domMove = function($tile, $board) {\n  var value = $tile.attr(\"value\");\n  var $oldEmpty = $board.find(\".empty\");\n  $tile.removeAttr(\"value\");\n  $tile.addClass('empty');\n  $oldEmpty.attr(\"value\", value);\n  $oldEmpty.removeClass('empty');\n};\n\nView.prototype.setupBoard = function ($board, gridArray) {\n  $board.html('');\n  for (var rowIdx = 0; rowIdx < this.game.gridSize; rowIdx++) {\n    var $ul = $('<ul>');\n\n    for (var colIdx = 0; colIdx < this.game.gridSize; colIdx++) {\n      var num = gridArray[rowIdx * this.game.gridSize + colIdx];\n      var $li;\n      if (num === null) {\n        $li = $('<li></li>');\n        if ($board !== this.$gridSolution) $li.addClass('empty');\n      } else {\n        $li = $('<li value=' + num + '></li>');\n      }\n      $li.data('pos', rowIdx * this.game.gridSize + colIdx);\n      $ul.append($li);\n    }\n\n    $board.append($ul);\n  }\n};\n\nView.prototype.timer = function () {\n  this.timeDisplay = setInterval(function () {\n    this.$time.html(Math.floor((new Date() - this.time) / 1000));\n  }.bind(this), 1000);\n};\n\nView.prototype.solvePuzzle = function () {\n  if (this.game) {\n    this.$puzzleSolution.html('');\n    _solutionNodes = this.game.getSolution();\n\n    if (_solutionNodes.length > 0) {\n      this.setupSolver();\n      this.$solverSteps.attr(\"max\", _solutionNodes.length - 1);\n      this.$solverSteps.focus();\n      var stepWord = (_solutionNodes.length - 1) === 1 ? 'step' : 'steps';\n      this.$solverCount.html(`${_solutionNodes.length - 1} ${stepWord}`);\n      this.setupSolverDetail();\n      this.handleStepInput(0);\n    } else {\n      this.$puzzleSolution.html('<h2>Solution not available. Try smaller grid.</h2>');\n    }\n  }\n};\n\nView.prototype.setupSolver = function () {\n  this.$gridSolver = $('<div id=\"grid-solver\">');\n  this.$solverSteps = $('<input id=\"solver-steps\" type=\"range\" min=\"0\" value=\"0\" step=\"1\">');\n  this.$solverPlay = $('<input id=\"solver-play\" class=\"button\" type=\"button\" value=\"Play\">');\n  this.$solverCount = $('<h3>');\n  this.$solverText = $('<div id=\"solver-text\">');\n  this.$puzzleSolution\n    .append(this.$gridSolver)\n    .append(this.$solverCount)\n    .append(\n      $('<div id=\"solver-detail\"><h2>Solution:</h2></div>')\n        .append(this.$solverCount)\n        .append(this.$solverText)\n    )\n    .append(\n      $('<div id=\"play-div\">')\n        .append(this.$solverSteps)\n        .append(this.$solverPlay)\n    );\n\n  this.$solverSteps.on('input', function (event) {\n    var step = parseInt(event.currentTarget.value);\n    this.setupBoard(this.$gridSolver, _solutionNodes[step].board.grid);\n    this.handleStepList(step);\n    this.$solverSteps.trigger('change');\n   }.bind(this));\n\n  this.$solverSteps.on('change', function (event) {\n    if (_playing) {\n      this.$solverPlay.val('Pause');\n    } else if (parseInt(this.$solverSteps.val()) === parseInt(this.$solverSteps.attr(\"max\"))) {\n      this.$solverPlay.val('Replay');\n    } else {\n      this.$solverPlay.val('Play');\n    }\n  }.bind(this));\n\n  this.$solverPlay.click(function (event) {\n    if (_playing) {\n      this.handleStopPlay();\n    } else {\n      if (parseInt(this.$solverSteps.val()) === parseInt(this.$solverSteps.attr(\"max\"))) {\n        this.handleStepInput(0);\n      }\n      _playing = setInterval(function () {\n        this.handleStepInput(parseInt(this.$solverSteps.val()) + 1);\n        if (parseInt(this.$solverSteps.val()) === parseInt(this.$solverSteps.attr(\"max\"))) {\n          this.handleStopPlay();\n        }\n      }.bind(this), 450);\n      this.$solverSteps.trigger('change');\n    }\n  }.bind(this));\n\n  this.$solverText.on('click', 'li', function (event) {\n    var $li = $(event.target).closest('li');\n    this.$solverSteps.val($li.data('step'));\n    this.$solverSteps.trigger('input');\n  }.bind(this));\n};\n\nView.prototype.handleStopPlay = function () {\n  clearInterval(_playing);\n  _playing = false;\n  this.$solverSteps.trigger('change');\n};\n\nView.prototype.setupSolverDetail = function () {\n  this.$solverText.html('');\n  var $ul = $('<ul>');\n\n  _solutionNodes.forEach(function(node, index) {\n    $ul.append(\n      $('<li>')\n        .data('step', index)\n        .html(node.moveString())\n        .prepend(\n          $('<span>')\n            .html(index+'.')\n          )\n    );\n  });\n\n  this.$solverText.append($ul);\n};\n\nView.prototype.handleStepInput = function (currentStep) {\n  this.$solverSteps.val(currentStep);\n  this.$solverSteps.trigger('input');\n};\n\nView.prototype.handleStepList = function (currentStep) {\n  var viewInstance = this;\n  $('li', this.$solverText).each(function() {\n    if ($(this).data('step') === currentStep) {\n      $(this).addClass('current');\n      handleListView($(this), viewInstance.$solverText, 50);\n    } else {\n      $(this).removeClass('current');\n    }\n  });\n};\n\nfunction handleListView($item, $list, scrollBuffer) {\n  var listTop = $list.offset().top;\n  var listBottom = listTop + $list.innerHeight();\n  var distFromTop = $item.offset().top - listTop;\n  var distFromBottom = $item.offset().top - listBottom;\n  var scrollState = $list.scrollTop();\n  var scrollDist = $list.innerHeight() - scrollBuffer;\n\n  if (distFromTop < scrollBuffer) {\n    scrollState -= scrollDist;\n  } else if (distFromBottom > -scrollBuffer) {\n    scrollState += scrollDist;\n  } else {\n    return;\n  }\n\n  $list.animate({scrollTop: scrollState}, 400);\n}\n\nmodule.exports = View;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/view.js\n ** module id = 1\n ** module chunks = 0\n **/","var Board = require('./board');\nvar Solver = require('./solver');\n\nfunction Game (gridSize) {\n  this.gridSize = gridSize || 3;\n  this.board = new Board(this.gridSize);\n  this.initialBoard = this.board.duplicate();\n}\n\nGame.prototype.playMove = function (pos) {\n  this.board.move(pos);\n};\n\nGame.prototype.isOver = function () {\n  return this.board.isOver();\n};\n\nGame.prototype.getSolution = function () {\n  if (!this.solution) {\n    this.solution = new Solver(this.initialBoard).solution;\n  }\n  return this.solution;\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 2\n ** module chunks = 0\n **/","var MoveError = require(\"./move_error\");\n\nfunction Board (gridSize) {\n  if (gridSize) {\n    this.gridSize = gridSize;\n    this.solution = Board.tileContent(this.gridSize);\n    while (!this.grid || this.isOver()) {\n      this.grid = Board.makeSolvable(this.solution);\n    }\n    this.emptyPosition = this.grid.indexOf(null);\n  }\n}\n\nBoard.prototype.duplicate = function () {\n  var newBoard = new Board();\n  newBoard.gridSize = this.gridSize;\n  newBoard.solution = this.solution;\n  newBoard.grid = this.grid.slice(0);\n  newBoard.emptyPosition = this.emptyPosition;\n  return newBoard;\n};\n\nfunction shuffleArray(array) {\n  var shuffled = array.slice(0);\n  for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = shuffled[i];\n      shuffled[i] = shuffled[j];\n      shuffled[j] = temp;\n  }\n  return shuffled;\n}\n\nBoard.makeSolvable = function (array) {\n  var tileArray = shuffleArray(array);\n  if (Board.isSolvable(tileArray)) {\n    return tileArray;\n  } else {\n    return Board.makeSolvable(tileArray);\n  }\n};\n\nBoard.tileContent = function (gridSize) {\n  var tileRange = [];\n  for (var i = 1; i < Math.pow(gridSize, 2); i++) {\n    tileRange.push(i);\n  }\n  tileRange.push(null);\n  return tileRange;\n};\n\nBoard.isSolvable = function (tileArray) {\n  var parity = 0;\n  var row = 0;\n  var gridSize = Math.sqrt(tileArray.length);\n  var blankRow = 0;\n\n  for (var i = 0; i < tileArray.length; i++) {\n    if (i % gridSize === 0) {\n      row++;\n    }\n\n    if (tileArray[i] === null) {\n      blankRow = row;\n    }\n\n    for (var j = i + 1; j < tileArray.length; j++) {\n      if (tileArray[i] > tileArray[j] && tileArray[j] !== null) {\n        parity++;\n      }\n    }\n  }\n\n  if (gridSize % 2 === 0 && blankRow % 2 !== 0) {\n    return parity % 2 !== 0;\n  } else {\n    return parity % 2 === 0;\n  }\n};\n\nBoard.prototype.isOver = function () {\n  return this.solution.toString() === this.grid.toString();\n};\n\nBoard.prototype.surroundingPositions = function (origPos) {\n  var positions = [];\n  var origCoords = Board.coords(origPos, this.gridSize);\n  positions.push(origPos + 1);\n  positions.push(origPos - 1);\n  positions.push(origPos + this.gridSize);\n  positions.push(origPos - this.gridSize);\n  return  positions.filter(function (pos) {\n    var posCoords = Board.coords(pos, this.gridSize);\n    var horizDist = Math.abs(posCoords[1] - origCoords[1]);\n    var vertDist = Math.abs(posCoords[0] - origCoords[0]);\n    return this.isValidPos(pos) && horizDist + vertDist == 1;\n  }.bind(this));\n};\n\nBoard.coords = function(pos, gridSize) {\n  var row = Math.floor(pos / gridSize);\n  var col = pos % gridSize;\n  return [row, col];\n};\n\nBoard.prototype.isValidPos = function (pos) {\n  return 0 <= pos && pos < Math.pow(this.gridSize, 2);\n};\n\nBoard.prototype.validMoves = function () {\n  return this.surroundingPositions(this.emptyPosition);\n};\n\nBoard.prototype.isValidMove = function (pos) {\n  return this.validMoves().includes(pos);\n};\n\nBoard.prototype.move = function (pos) {\n  if (!this.isValidMove(pos)) {\n    throw new MoveError(\"Is not valid position\");\n  }\n  var currentEmpty = this.emptyPosition;\n  this.grid[currentEmpty] = this.grid[pos];\n  this.emptyPosition = pos;\n  this.grid[pos] = null;\n  return Board.moveInfo(currentEmpty, pos, this);\n};\n\nBoard.determineDirection = function (currentEmpty, nextEmpty, gridSize) {\n  var from = Board.coords(currentEmpty, gridSize);\n  var to = Board.coords(nextEmpty, gridSize);\n  var direction;\n  if (from[0] - to[0] === 1) {\n    direction = \"down\";\n  } else if (from[0] - to[0] === -1) {\n    direction = \"up\";\n  } else if (from[1] - to[1] === 1) {\n    direction = \"right\";\n  } else if (from[1] - to[1] === -1) {\n    direction = \"left\";\n  }\n  return direction;\n};\n\nBoard.moveInfo = function (to, from, board) {\n  // used on the board after the move\n  return {\n    \"value\" : board.grid[to],\n    \"from\" : from,\n    \"to\" : to,\n    \"direction\" : Board.determineDirection(to , from, board.gridSize)\n  };\n};\n\nBoard.moveInfoString = function(moveInfo) {\n  if (!jQuery.isEmptyObject(moveInfo)) {\n    return `${moveInfo.value} ${moveInfo.direction} from ${moveInfo.from} to ${moveInfo.to}`;\n  } else {\n    return \"Initial Board\";\n  }\n};\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/board.js\n ** module id = 3\n ** module chunks = 0\n **/","function MoveError (msg) {\n  this.msg = msg;\n}\n\nmodule.exports = MoveError;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/move_error.js\n ** module id = 4\n ** module chunks = 0\n **/","var Board = require(\"./board\");\nvar PuzzleNode = require(\"./puzzle_node\");\nvar PriorityQueue = require(\"./priority_queue\");\n\nfunction Solver(board) {\n  var solverBoard = board.duplicate();\n  this.solution = findSolution(solverBoard);\n}\n\nfunction possibleBoards(board) {\n  return board.validMoves().map(function(pos) {\n    var newBoard = board.duplicate();\n    newBoard.move(pos);\n    return newBoard;\n  });\n}\n\nfunction manhattanDistace(board) {\n  return board.grid.reduce(function(distance, currentTile, index) {\n    var adder = 0;\n    if (currentTile) {\n      var correctPos = currentTile - 1;\n      var colDist = Math.abs(index % board.gridSize - correctPos % board.gridSize);\n      var rowDist = Math.abs(Math.floor(index / board.gridSize) - Math.floor(correctPos / board.gridSize));\n      adder = colDist + rowDist;\n    }\n    return distance + adder;\n  }, 0);\n}\n\nfunction findSolution(board) {\n  if (board.gridSize > 3) return [];\n  var visited = {};\n  visited[board.grid] = true;\n  var rootNode = new PuzzleNode(board);\n  rootNode.priority = manhattanDistace(rootNode.board);\n  var boardQueue = new PriorityQueue([rootNode]);\n  var currentNode = boardQueue.pop();\n  var solved;\n  while (currentNode) {\n    var currentBoard = currentNode.board;\n    if (currentBoard.isOver()) {\n      solved = currentNode;\n      break;\n    }\n    var nextBoards = filterVisited(possibleBoards(currentBoard), visited);\n    boardQueue.add(nextBoards.map(function (board) {\n      var nextNode = new PuzzleNode(board);\n      nextNode.distance = currentNode.distance + 1;\n      nextNode.priority = nextNode.distance + manhattanDistace(nextNode.board);\n      nextNode.move = Board.moveInfo(currentBoard.emptyPosition, board.emptyPosition, board);\n      nextNode.setParent(currentNode);\n      return nextNode;\n    }));\n    currentNode = boardQueue.pop();\n  }\n  return solved ? traceBack(solved) : [];\n}\n\nfunction filterVisited(boards, visited) {\n  return boards.filter(function(board) {\n    var isVisited = !visited[board.grid];\n    visited[board.grid] = true;\n    return isVisited;\n  });\n}\n\nfunction traceBack(endNode) {\n  var nodes = [];\n  var currentNode = endNode;\n  while (currentNode) {\n    nodes.unshift(currentNode);\n    currentNode = currentNode.parent;\n  }\n  return nodes;\n}\n\nfunction solutionString(solution) {\n  return solution.map(function(node) {\n    return node.moveString();\n  });\n}\n\nmodule.exports = Solver;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/solver.js\n ** module id = 5\n ** module chunks = 0\n **/","var Board = require(\"./board\");\n\nfunction PuzzleNode(board) {\n  this.board = board;\n  this.move = {};\n  this.parent = null;\n  this.children = [];\n  this.distance = 0;\n  this.priority = 0;\n}\n\nPuzzleNode.prototype.setParent = function (parent) {\n  this.parent = parent;\n  if (this.parent) this.parent.children.push(this);\n};\n\nPuzzleNode.prototype.addChild = function (child) {\n  child.setParent(this);\n};\n\nPuzzleNode.prototype.moveString = function () {\n  return Board.moveInfoString(this.move);\n};\n\nmodule.exports = PuzzleNode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/puzzle_node.js\n ** module id = 6\n ** module chunks = 0\n **/","function PriorityQueue(nodes) {\n  this.heap = [null];\n  this.add(nodes);\n}\n\nPriorityQueue.prototype = {\n  add: function(nodes) {\n    nodes.forEach(function(node) {\n      this.push(node);\n    }.bind(this));\n  },\n\n  push: function(node) {\n    this.bubble(this.heap.push(node) - 1);\n  },\n\n  // removes and returns the node of highest priority\n  pop: function() {\n    var topVal = this.heap[1];\n    this.heap[1] = this.heap.pop();\n    this.sink(1);\n    return topVal;\n  },\n\n  // bubbles node i up the binary tree based on\n  // priority until heap conditions are restored\n  bubble: function(i) {\n    while (i > 1) {\n      var parentIndex = i >> 1; // <=> floor(i/2)\n\n      // if equal, no bubble (maintains insertion order)\n      if (!this.isHigherPriority(i, parentIndex)) break;\n\n      this.swap(i, parentIndex);\n      i = parentIndex;\n    }\n  },\n\n  // does the opposite of the bubble() function\n  sink: function(i) {\n    while (i * 2 < this.heap.length) {\n      // if equal, left bubbles (maintains insertion order)\n      var leftHigher = true;\n      if (this.heap.length - 1 >= i * 2 + 1) {\n        leftHigher = this.isHigherPriority(i * 2, i * 2 + 1);\n      }\n      var childIndex = leftHigher ? i * 2 : i * 2 + 1;\n\n      // if equal, sink happens (maintains insertion order)\n      if (this.isHigherPriority(i, childIndex)) break;\n\n      this.swap(i, childIndex);\n      i = childIndex;\n    }\n  },\n\n  // swaps the addresses of 2 nodes\n  swap: function(i, j) {\n    var temp = this.heap[i];\n    this.heap[i] = this.heap[j];\n    this.heap[j] = temp;\n  },\n\n  // returns true if node i is higher priority than j\n  isHigherPriority: function(i, j) {\n    return this.heap[i].priority < this.heap[j].priority;\n  }\n};\n\nmodule.exports = PriorityQueue;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/priority_queue.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}